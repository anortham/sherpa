name: "General Development"
description: "Balanced workflow for most tasks - research, plan, test, implement, verify"
trigger_hints:
  - "default"
  - "general"
  - "feature"
  - "implement"
  - "add"
  - "create"
  - "build"
  - "develop"

phases:
  - name: "üìö Research"
    guidance: "Don't guess - KNOW. Understanding before coding prevents building the wrong thing."
    suggestions:
      - "Read relevant documentation (official docs, not blog posts)"
      - "Search codebase for similar existing patterns or features"
      - "Verify API signatures, types, and return values (don't assume)"
      - "Check how related features are implemented (consistency matters)"
      - "Look for existing tests that show usage patterns"
      - "Review error handling in similar code (what can go wrong?)"
      - "Check git history if modifying existing code (why was it built this way?)"
      - "Identify dependencies and their versions (compatibility check)"

    conditionals:
      - condition: "If working with unfamiliar library/framework"
        action: "Read official getting-started docs AND API reference. Run official examples to understand behavior. Don't rely on assumptions."
      - condition: "If modifying existing feature"
        action: "Read ALL related code first (not just the file you think you need to change). Features often span multiple files."
      - condition: "If unclear what 'done' looks like"
        action: "Find product spec, user story, or ticket. If none exist, ask for clarification BEFORE coding. Assumptions = rework."
      - condition: "If similar feature exists"
        action: "Study it thoroughly. Copy the pattern - consistency > creativity in most codebases."

    anti_patterns:
      - pattern: "Skipping research because 'I know how to do this'"
        guidance: "Pride before the fall. Every codebase has quirks. Read the actual code, don't assume you know the patterns."
      - pattern: "Using Stack Overflow answer without understanding it"
        guidance: "Copy-paste = future bugs. Understand WHY the solution works. Read the official docs it references."
      - pattern: "Starting to code while still unclear on requirements"
        guidance: "Building wrong thing wastes more time than clarifying upfront. Get clarity BEFORE code."

  - name: "üìù Plan"
    guidance: "Explain before implementing - a good plan saves hours of backtracking"
    suggestions:
      - "Write out your approach in comments or design doc"
      - "List the files you'll need to modify/create"
      - "Identify potential issues and edge cases upfront"
      - "List assumptions that need verification"
      - "Consider alternative approaches (pros/cons of each)"
      - "Think through error handling (what can fail? how to handle?)"
      - "Plan for backwards compatibility if modifying existing code"
      - "Estimate complexity - simple vs complex approaches"

    conditionals:
      - condition: "If multiple approaches are possible"
        action: "Write pros/cons for each. Choose based on: simplicity, maintainability, performance (in that order). Prefer simple."
      - condition: "If plan feels too complex"
        action: "Look for simpler approach. Complexity is often sign you're solving wrong problem or over-engineering."
      - condition: "If you're unsure about approach"
        action: "Prototype the risky/uncertain part first (spike). Learn, then plan properly with knowledge gained."
      - condition: "If touching critical/complex code"
        action: "Add extra detail to plan. Consider pair programming or code review BEFORE implementing."

    anti_patterns:
      - pattern: "Planning in your head without writing it down"
        guidance: "Mental plans evaporate. Written plans catch holes and can be reviewed. Always write the plan."
      - pattern: "Skipping planning because task seems simple"
        guidance: "'Simple' tasks often have hidden complexity. 5 minutes of planning prevents hours of refactoring."
      - pattern: "Over-planning (spending hours on detailed design docs)"
        guidance: "Paralysis by analysis. Plan enough to start confidently, not perfectly. Iterate as you learn."

  - name: "üß™ Test Setup"
    guidance: "Tests guide implementation - write test structure BEFORE implementation code"
    suggestions:
      - "Create test file following project conventions"
      - "Write test cases for happy path (expected behavior)"
      - "Write test cases for edge cases identified in planning"
      - "Write test cases for error conditions (invalid input, failures)"
      - "Define clear success criteria (what 'passing' means)"
      - "Set up test data/fixtures you'll need"
      - "Mock external dependencies (APIs, databases, file system)"
      - "Start with simplest test case to prove basic functionality"

    conditionals:
      - condition: "If you're not sure what to test"
        action: "Start with: 1) Does function exist? 2) Happy path works? 3) Null/empty input handled? 4) Errors throw/return correctly?"
      - condition: "If feature is complex with many cases"
        action: "Write test NAMES first (describe what you'll test), then implement tests one at a time. Don't get overwhelmed."
      - condition: "If testing legacy code without tests"
        action: "Start with characterization tests (test current behavior even if wrong). Then add tests for new behavior."
      - condition: "If tests would be slow (database, network, etc.)"
        action: "Mock dependencies. Unit tests should run in milliseconds. Save integration tests for critical paths only."

    anti_patterns:
      - pattern: "Writing implementation before tests"
        guidance: "Wrong order. Tests written first ensure: 1) Testable design, 2) Tests actually verify behavior. Test-after often miss bugs."
      - pattern: "Only testing happy path"
        guidance: "Bugs hide in edge cases and error paths. Test: happy path, edge cases, error conditions. All three."
      - pattern: "Skipping test setup because 'I'll add tests later'"
        guidance: "Later never comes. Write tests NOW while requirements are fresh. Future you will thank present you."

  - name: "üíª Implement"
    guidance: "Code with confidence - follow the plan, let tests guide you"
    suggestions:
      - "Follow the plan you wrote (don't deviate without updating plan)"
      - "Start with simplest test - make it pass"
      - "Run tests after each function/method (rapid feedback)"
      - "Verify types as you go (TypeScript errors are your friend)"
      - "Handle errors explicitly (no silent failures)"
      - "Add logging for debugging (you'll need it later)"
      - "Keep functions small and focused (easier to test and understand)"
      - "Don't add features not in the plan/tests (scope creep)"

    conditionals:
      - condition: "If test fails unexpectedly"
        action: "Don't just fix code - understand WHY. Test might have revealed edge case or incorrect assumption. This is valuable feedback."
      - condition: "If you want to deviate from plan"
        action: "Pause. Update plan with new approach and reasoning. Then continue. Don't ad-hoc deviate."
      - condition: "If implementation is getting messy"
        action: "Acceptable for now. Make tests pass first, then refactor. Green first, clean second."
      - condition: "If you discover missing test case during implementation"
        action: "STOP. Write the missing test BEFORE continuing implementation. Don't leave gaps."

    anti_patterns:
      - pattern: "Implementing features not covered by tests or plan"
        guidance: "Scope creep. Stick to plan. Additional features can be added in separate iteration with their own tests."
      - pattern: "Ignoring type errors or warnings"
        guidance: "Errors are trying to tell you something. Fix them. They prevent bugs."
      - pattern: "Copying code without understanding it"
        guidance: "You'll own this code. Understand what it does. Refactor if you can't explain it simply."
      - pattern: "Not running tests frequently"
        guidance: "Run tests after each change. Fast feedback catches bugs when context is fresh. Don't accumulate untested code."

  - name: "‚úÖ Verify"
    guidance: "Make sure it actually works - tests passing isn't enough"
    suggestions:
      - "All tests passing? (Run full test suite, not just your new tests)"
      - "Manual testing with realistic data (not just test fixtures)"
      - "Test edge cases manually (boundary values, empty input, etc.)"
      - "Test error cases manually (trigger error conditions, verify handling)"
      - "Check that UX makes sense (if user-facing feature)"
      - "Verify backwards compatibility (if modifying existing feature)"
      - "Review your own code (read it fresh, as if reviewing someone else's)"
      - "Update documentation if behavior changed or feature is new"

    conditionals:
      - condition: "If manual testing reveals bug"
        action: "Write test that catches the bug, then fix. This prevents regression. Don't just fix without test."
      - condition: "If you're unsure about edge case behavior"
        action: "Test it manually. If behavior is important, add automated test for it."
      - condition: "If feature has user-facing changes"
        action: "Test with realistic user workflow. Don't just test isolated feature - test in context."
      - condition: "If tests pass but manual testing shows issue"
        action: "Tests are incomplete. Add missing test cases. Tests should catch everything manual testing catches."

    anti_patterns:
      - pattern: "Skipping manual testing because 'tests pass'"
        guidance: "Tests can have blind spots. Always verify manually. Tests prove correctness, manual testing proves usability."
      - pattern: "Testing only on your machine/environment"
        guidance: "Environment matters. Test in environment similar to production (staging, docker, etc.)"
      - pattern: "Marking done without updating documentation"
        guidance: "Code is for humans to read. If behavior changed, update docs. Future developers (including you) will need them."
      - pattern: "Not running full test suite before committing"
        guidance: "Your changes might break something elsewhere. ALWAYS run full suite. Regressions waste everyone's time."
