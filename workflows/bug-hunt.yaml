name: "Bug Hunt"
description: "Debug systematically with test-driven bug fixing - prevents symptom fixing and ensures bugs stay fixed"
trigger_hints:
  - "bug"
  - "broken"
  - "fix"
  - "issue"
  - "failing"
  - "error"
  - "crash"
  - "regression"
  - "incorrect"
  - "unexpected"

phases:
  - name: "üîç Reproduce & Isolate"
    guidance: "Understand the bug completely BEFORE touching code - rushing to fix symptoms wastes time"
    suggestions:
      - "Reproduce the bug manually first - verify it actually happens"
      - "Document exact steps to reproduce (input ‚Üí expected ‚Üí actual behavior)"
      - "Identify minimal reproduction case (remove everything unrelated)"
      - "Check if this is actually a bug or misunderstood feature (read specs/docs)"
      - "Read the actual code path being executed (don't assume)"
      - "Add logging/debugging to understand data flow"
      - "Check git history: when was this last working? what changed?"
      - "Verify bug exists in codebase, not just environment/config"

    conditionals:
      - condition: "If you can't reproduce the bug"
        action: "Get more information from reporter. Ask for: exact steps, environment, screenshots, logs. Can't fix what you can't reproduce."
      - condition: "If bug only happens in specific environment"
        action: "Compare working vs broken environment configs. Check: versions, feature flags, environment variables, data state."
      - condition: "If bug is intermittent/race condition"
        action: "Add extensive logging around suspected area. Look for timing dependencies, async operations, shared state."
      - condition: "If git history shows recent changes in area"
        action: "Use git bisect to find exact commit that introduced bug. This reveals root cause quickly."

    anti_patterns:
      - pattern: "Immediately jumping to code and trying fixes"
        guidance: "STOP. Understand first, fix second. Fixing without understanding leads to symptom-fixing and bugs that come back."
      - pattern: "Assuming you know the cause without reading code"
        guidance: "Assumptions = bugs. Read the ACTUAL code being executed. It often does something different than you think."
      - pattern: "Testing in your head instead of actually reproducing"
        guidance: "Mental reproduction isn't reliable. Actually run the code with bug-triggering input. See it fail with your eyes."
      - pattern: "Skipping minimal reproduction (just working with full case)"
        guidance: "Minimal case reveals root cause. Remove everything unrelated - bug becomes obvious when isolated."

  - name: "üéØ Capture in Test"
    guidance: "Lock down the bug with a failing test - this prevents regression and proves the fix works"
    suggestions:
      - "Write test that reproduces the EXACT bug behavior"
      - "Test should FAIL in the same way the bug manifests"
      - "Use minimal reproduction case from phase 1 as test input"
      - "Name test descriptively: test_bug_[issue_number]_[specific_behavior]"
      - "Include comment explaining what bug this test prevents"
      - "Verify test fails for the RIGHT reason (matches actual bug)"
      - "Run test multiple times to ensure it's deterministic"
      - "If bug is in error handling, test should expect wrong error/behavior"

    conditionals:
      - condition: "If test passes even though bug exists"
        action: "Test isn't actually testing the bug. Review reproduction steps. Test must fail the SAME WAY bug manifests."
      - condition: "If test is flaky (sometimes passes, sometimes fails)"
        action: "Stabilize test first before fixing bug. Flaky tests can't prove fix works. Look for race conditions, timing, state pollution."
      - condition: "If bug is complex integration issue"
        action: "Write integration test that fails, THEN add unit tests for suspected components. Work from high-level failure down to root cause."
      - condition: "If bug involves multiple components"
        action: "Start with test at highest level that shows bug. Then add focused unit tests for each component. Pinpoint exact failure."

    anti_patterns:
      - pattern: "Writing test after fixing the bug"
        guidance: "Wrong order! Test FIRST ensures: 1) Test actually catches bug, 2) Fix is proven to work. Test-after can pass even with broken fix."
      - pattern: "Making test pass by changing test (not fixing bug)"
        guidance: "NO. Test represents correct behavior. If test 'fails wrong', you misunderstood bug. Re-examine actual vs expected behavior."
      - pattern: "Writing test that's too broad (tests multiple things)"
        guidance: "Focused test reveals exact root cause. Broad test might pass for wrong reason. One test = one bug scenario."
      - pattern: "Skipping this phase because 'fix is obvious'"
        guidance: "Not obvious enough to prevent it in first place. Test prevents regression. 2 minutes now saves hours later when bug returns."

  - name: "üîß Fix & Verify"
    guidance: "Make the test pass with minimal, surgical changes - no scope creep, no refactoring yet"
    suggestions:
      - "Fix ONLY the bug - resist the urge to improve other things"
      - "Change minimal code to make failing test pass"
      - "Run the specific failing test - verify it now passes"
      - "Run FULL test suite - ensure no regressions introduced"
      - "Test manually with original reproduction steps - confirm fixed"
      - "Search codebase for similar patterns - check if bug exists elsewhere"
      - "Document WHY the fix works in code comment or commit message"
      - "Consider if fix reveals design issue (note for future refactor)"

    conditionals:
      - condition: "If test passes but manual testing still shows bug"
        action: "Test isn't comprehensive enough. Add more test cases covering the missed scenario. Test must catch everything."
      - condition: "If fix requires changing many files or lots of code"
        action: "Probably fixing symptom, not root cause. Re-examine. True root cause fix is usually small and surgical."
      - condition: "If other tests break after your fix"
        action: "Your fix changed behavior those tests depend on. Either: 1) Fix introduced new bug, or 2) Old tests tested wrong behavior. Investigate carefully."
      - condition: "If you found similar bug pattern elsewhere"
        action: "Fix all instances in same commit. Write tests for each. Same bug in multiple places = systemic issue."

    anti_patterns:
      - pattern: "Fixing bug + refactoring + adding features in same change"
        guidance: "Scope creep. Fix ONLY the bug. Refactor in separate commit. This makes bug fix easy to review, deploy, rollback."
      - pattern: "Fixing symptom instead of root cause"
        guidance: "Symptom fixes don't last. Find WHERE bug originates, not where it surfaces. Follow data flow backward to source."
      - pattern: "Not running full test suite (just the new test)"
        guidance: "Dangerous. Your fix might break something else. ALWAYS run full suite. Regressions are worse than original bug."
      - pattern: "Removing or weakening existing tests to make yours pass"
        guidance: "NEVER. If old test conflicts with your fix, investigate why. Either your fix is wrong or old test tested incorrect behavior."
      - pattern: "Deploying fix without confirming manual reproduction is fixed"
        guidance: "Test passes != bug is fixed. Verify MANUALLY with original reproduction steps. Tests can have false positives."
